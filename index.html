<!DOCTYPE html>
<html>
  <head>
    <title>Earthquakes</title>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="http://d3js.org/topojson.v2.min.js"></script>
    <script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
    <style>

      h1 {
        text-align: center;
        font-family: Helvetica;
        font-size: 72;
      }

    </style>
  </head>
  <body>

    <div id="page">
        <h1></h1>
        <svg id="map" width="1000" height="500"></svg>
        <svg id="pie" width="300" height="500"></svg>   
        <br>
        <svg id="time" width="1000" height="70"></svg>   
    </div>
    <p id="slider"></p>

        <script type="text/javascript">
          // Constants
          var YEAR_MIN = 1965
          var YEAR_MAX = 2016
          
          // The data we are visualizing
          var countries
          var plates
          var database
          var stats

          // "Indicator" variables for data
          var currentYear = YEAR_MIN
          var depthExtent 
          var currentCountry

          // SVGs
          var mapSvg = d3.select("#map")
          var timeSvg = d3.select("#time")
          var pieSvg = d3.select("#pie")

          // Projection and path generators for map
          var projection = d3.geoKavrayskiy7().scale(153)
          var pathGenerator = d3.geoPath().projection(projection)

          // A representation of the slider
          var sliderTopMargin = 20
          var sliderSideMargin = 120
          var timeSlider = {
            top: 20,
            bottom: 35,
            left: sliderSideMargin,
            right: timeSvg.attr("width") - sliderSideMargin,
            scale: d3.scaleLinear()
              .domain([YEAR_MIN, YEAR_MAX])
              .range([sliderSideMargin, timeSvg.attr("width") - sliderSideMargin]),
            thickness: 5,
            radius: 10,
            axis: null,
            handler: null
          }

          // Turn each value in a row of the database into a something workable
          function parseDatabase(row) {
            time = row.Time.split(":")

            d = {
              lat: +row.Latitude,
              lng: +row.Longitude,
              depth: +row.Depth,
              date: row.Date,
              time: time[0] + ":" + time[1],
              year: +row.Date.split("/")[2]
            }

            return d
          }

          // Load each of the pieces we need
          d3.queue()
            .defer(d3.json, "world-50m.json")
            .defer(d3.json, "PB2002_plates.json")
            .defer(d3.tsv, "world-country-names.tsv")
            .defer(d3.csv, "earthquake-database.csv", parseDatabase)
            .defer(d3.json, "earthquake-stats.json")
            .await(ready)

          // Once data is ready, perform some preprocessing
          function ready(error, rawWorld, rawPlates, rawNames, rawDatabase, rawStats) {
            if (error) throw error

            // Associate a name with each of the countries
            countries = topojson.feature(rawWorld, rawWorld.objects.countries)
            countries.features = countries.features.filter(function (d) {
              return rawNames.some(function (n) {
                if (d.id == n.id) {
                  d.name = n.name 
                  return true
                } 
              })
            })

            // Get features of the plates dataset
            plates = topojson.feature(rawPlates, rawPlates.objects.collection)
            
            // Preprocess database and stats
            database = rawDatabase
            stats = rawStats

            // Throw out stats with no corresponding country (less than 5% of dataset)
            stats = stats.filter(function (d) {
              return countries.features.some(function (n) {
                var dname = d.country.toLowerCase()
                var nname = n.name.toLowerCase().split(" and ")
                if (nname.some(k => dname.includes(k))) {
                  d.country = n.name
                  d.id = n.id
                  return true
                }
              })
            })

            // Remove earthquake from database if its associated with a stat
            database = database.filter(function (d) {
              var found = stats.some(function (n) {
                if (n.date == d.date && n.time == d.time) {
                  return true
                }
              })
              return found ? false : true
            })

            // Pre-compute useful information about the datasets
            depthExtent = d3.extent(database, d => d.depth)

            // Load the main view
            loadView()
          }

          // Load our view
          function loadView(year) {
            loadMap()            
            loadSlider()
            updateYear(currentYear) //default year
          }

          // Load our map with some config constraints
          function loadMap() {
            var width = mapSvg.attr("width")
            var height = mapSvg.attr("height")

            // Draw the map
            projection.fitExtent([[0,0], [width, height]], countries)
            pathGenerator = d3.geoPath().projection(projection)

            // Draw the tectonic plates
            var tectonicPaths = mapSvg.selectAll("path.tectonic").data(plates.features)
            tectonicPaths.enter()
              .append("path")
              .attr("class", "tectonic")
              .merge(tectonicPaths) 
              .attr("d", pathGenerator)
              .style("fill", "white")
              .style("stroke", "green")
              .style("stroke-width", 1)
              .style("opacity", 0.2)

            // Draw the countries
            var countryPaths = mapSvg.selectAll("path.country").data(countries.features)
            countryPaths.enter()
              .append("path")
              .attr("class", "country")
              .merge(countryPaths) 
              .attr("d", pathGenerator)
              .style("fill", "white")
              .style("stroke", "black")
          }

          // Load a slider
          function loadSlider() {
            var drag = d3.drag()
            .on("drag", sliderInput)

            // Default the slider at one end
            timeSvg.datum({
              x: timeSlider.left,
              y: timeSlider.top
            })

            // Draw a line for the slider axis
            timeSlider.axis = timeSvg.append("line")
              .attr("x1", timeSlider.left)
              .attr("x2", timeSlider.right)
              .attr("y1", timeSlider.top)
              .attr("y2", timeSlider.top)
              .style("stroke", "#ddd")
              .style("stroke-width", 5)

            // Draw a circle for the slider handler
            timeSlider.handler = timeSvg.append("circle")
              .attr("r", 10)
              .attr("cy", function(d) { return d.y })
              .attr("cx", function(d) { return d.x })
              .style("fill", "#fff")
              .style("stroke", "#000")
              .call(drag)

            // Attach an axis showing the years
            timeSvg.append("g")
              .attr("transform", "translate(0," + timeSlider.bottom + ")")
              .call(d3.axisBottom(timeSlider.scale)
                .tickFormat(d3.format("d")))

          }

          // Update the earthquake locations displayed to show
          function updateYear(year) {

            // Filter data by year
            var databaseYear = database.filter(function (d) {
              return d.year == year
            })

            // Filter stats by year
            var statsYear = stats.filter(function (d) {
              return d.year == year
            })

            // Filter countries by year
            var countriesYear = countries.features.filter(function (d) {
              return statsYear.some(function (n) {
                if (n.id == d.id) return true
              })
            })

            // Depth scale (just in case)
            var r = d3.scaleLinear().domain(depthExtent).range([3, 10])

            // Draw the countries
            var pathsDamaged = mapSvg.selectAll(".damaged").data(countriesYear)
            pathsDamaged.exit().remove()
            pathsDamaged.enter()
              .append("path")
              .attr("class", "damaged")
              .merge(pathsDamaged) 
              .attr("d", pathGenerator)
              .style("fill", "orange")
              .style("opacity", 1)

            // Draw the circles for every earthquake
            var circlesEarthquake = mapSvg.selectAll(".earthquake").data(databaseYear)
            circlesEarthquake.exit().remove()
            circlesEarthquake.enter()
              .append("circle")
              .attr("class", "earthquake")
              .merge(circlesEarthquake)
              .attr("cx", function (d) { return projection([d.lng, d.lat])[0] })
              .attr("cy", function (d) { return projection([d.lng, d.lat])[1] })
              .attr("r", 4)
              .style("fill", "blue")
              .style("opacity", 0.7)
            
            // Draw the circles for every earthquake in the stats
            var circlesDisaster = mapSvg.selectAll(".disaster").data(statsYear)
            circlesDisaster.exit().remove()
            circlesDisaster.enter()
              .append("circle")
              .attr("class", "disaster")
              .merge(circlesDisaster)
              .attr("cx", function (d) { return projection([d.lng, d.lat])[0] })
              .attr("cy", function (d) { return projection([d.lng, d.lat])[1] })
              .attr("r", 4)
              .style("fill", "blue")
              .style("opacity", 0.7)
            

            drawPie(statsYear)

            // Update the header
            d3.select("h1").text("Earthquakes versus Us: " + year)
          }

          // Draw the pie chart displaying countries affected
          function drawPie(statsYear) {
            // Determine the radious for the pie chart
            var radius = Math.min(pieSvg.attr("width"), pieSvg.attr("height")) / 2
            
            // Accumulate the countries damaged in a JSON
            var countriesDamaged = {}
            for (var i = 0; i < statsYear.length; i++) {
              var stat = statsYear[i]
              if (countriesDamaged[stat.country] == undefined) {
                countriesDamaged[stat.country] = stat.deaths
              } else {
                countriesDamaged[stat.country] = countriesDamaged[stat.country] + stat.deaths
              }
            }

            // Convert this JSON into an array
            var countryDeaths = []
            for (country in countriesDamaged) {
              countryDeaths.push({
                country: country,
                deaths: countriesDamaged[country]
              })
            } 
            countryDeaths.sort(function (a, b) {
              return a.country.localeCompare(b.country)
            })

            // A pie that uses the log() of deaths as its values
            var pie = d3.pie()
            .value(d => Math.log(d.deaths)/Math.log(2))

            // An arc configure for maximum donutness
            var arc = d3.arc()
            .innerRadius(radius * 4 / 8)
            .outerRadius(radius * 6 / 8)

            // Draw the arc for country
            var arcsStat = pieSvg.selectAll(".arc").data(pie(countryDeaths))
            arcsStat.exit().remove()
            arcsStat.enter()
              .append("path")
              .attr("class", "arc")
              .merge(arcsStat)
              .attr("d", arc)
              .attr("transform", "translate(" + pieSvg.attr("width") / 2 + "," + pieSvg.attr("height") / 2 + ")")
              .style("fill", "orange")
              .style("stroke", "white")
              .style("opacity", 1)
              .on("mouseover", mouseoverCountry)
          }

          // Mouseover callback for country in pie char
          function mouseoverCountry(d) {
            console.log(d.data)
          }

          // Slider callback for changing time
          function sliderInput(d) {
            var xmin = timeSlider.left
            var xmax = timeSlider.right

            // Bound the event's x coordinate
            var x = d3.event.x            
            x = x < xmin ? xmin : x > xmax ? xmax : x

            // Compute the year and recompute the the snapped location
            x = (x - timeSlider.left) / (timeSlider.right - timeSlider.left)
            x *= (YEAR_MAX - YEAR_MIN)
            x = YEAR_MIN + Math.floor(x + 0.5) 

            // Alter the slider and current year if there's a change
            if (currentYear != x) {
              updateYear(x)
              currentYear = x
              x = timeSlider.scale(x)
              d.x = x
              timeSlider.handler.attr("cx", x)
            }
            
          }

        </script>
      </div>

  </body>
</html>