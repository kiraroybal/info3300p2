<!DOCTYPE html>
<html>
  <head>
    <title>Earthquakes</title>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="http://d3js.org/topojson.v2.min.js"></script>
    <script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
    <style>

      h1 {
        text-align: center;
        font-family: Helvetica;
        font-size: 72;
      }

    </style>
  </head>
  <body>

    <div id="page">
        <h1></h1>
          <svg id="map" width="1000" height="500"></svg>
        <svg id="pie" width="300" height="500"></svg>   
        <br>
        <svg id="time" width="1000" height="70"></svg>   
    </div>
    <p id="slider"></p>

        <script type="text/javascript">
          // Constants
          var YEAR_MIN = 1965
          var YEAR_MAX = 2016
          var ZOOM_TIME = 400

          // The data we are visualizing
          var countries
          var plates
          var database
          var stats

          // "Indicator" variables for data
          var currentYear = YEAR_MIN
          var databaseYear
          var statsYear
          var countriesYear
          var depthExtent 
          var currentCountry = ""

          // SVGs
          var mapSvg = d3.select("#map")
          var timeSvg = d3.select("#time")
          var pieSvg = d3.select("#pie")
          // Groups for each set of things we render
          var mapGroup = mapSvg.append("g")
          var platesGroup = mapGroup.append("g")
          var countriesGroup = mapGroup.append("g")
          var damagedGroup = mapGroup.append("g")
          var earthquakesGroup = mapGroup.append("g")
          var disastersGroup = mapGroup.append("g")
          var statText1 = pieSvg.append("text")
          statText1.attr("x", 150)
            .attr("y", 25)
            .attr("text-anchor", "middle")
            .style("font-size", 24)
            .style("font-family", "Helvetica")
            .style("alignment-baseline", "central")
          var statText2 = pieSvg.append("text")
          statText2.attr("x", 150)
            .attr("y", 55)
            .attr("text-anchor", "middle")
            .style("font-size", 24)
            .style("font-family", "Helvetica")
            .style("alignment-baseline", "central")
          var statText3 = pieSvg.append("text")
          statText3.attr("x", 150)
            .attr("y", 85)
            .attr("text-anchor", "middle")
            .style("font-size", 24)
            .style("font-family", "Helvetica")
            .style("alignment-baseline", "central") 
          var statText4 = pieSvg.append("text")
          statText4.attr("x", 150)
            .attr("y", 115)
            .attr("text-anchor", "middle")
            .style("font-size", 24)
            .style("font-family", "Helvetica")
            .style("alignment-baseline", "central")         
          // Locks for concurrent transitions
          var platesGroupLock
          var countriesGroupLock
          var damagedGroupLock
          var earthquakesGroupLock
          var disastersGroupLock
          
          // Projection and path generators for map
          var projection = d3.geoKavrayskiy7()
            .scale(153)
            .fitExtent([[0,0], 
                [mapSvg.attr("width"), mapSvg.attr("height")]
              ], 
              countries)
          var pathGenerator = d3.geoPath().projection(projection)

          // A representation of the slider
          var sliderTopMargin = 20
          var sliderSideMargin = 120
          var timeSlider = {
            top: 20,
            bottom: 35,
            left: sliderSideMargin,
            right: timeSvg.attr("width") - sliderSideMargin,
            scale: d3.scaleLinear()
              .domain([YEAR_MIN, YEAR_MAX])
              .range([sliderSideMargin, timeSvg.attr("width") - sliderSideMargin]),
            thickness: 5,
            radius: 10,
            axis: null,
            handler: null
          }

          // Turn each value in a row of the database into a something workable
          function parseDatabase(row) {
            time = row.Time.split(":")

            d = {
              lat: +row.Latitude,
              lng: +row.Longitude,
              depth: +row.Depth,
              date: row.Date,
              time: time[0] + ":" + time[1],
              year: +row.Date.split("/")[2]
            }

            return d
          }

          // Load each of the pieces we need
          d3.queue()
            .defer(d3.json, "world-50m.json")
            .defer(d3.json, "PB2002_plates.json")
            .defer(d3.tsv, "world-country-names.tsv")
            .defer(d3.csv, "earthquake-database.csv", parseDatabase)
            .defer(d3.json, "earthquake-stats.json")
            .await(ready)

          // Once data is ready, perform some preprocessing
          function ready(error, rawWorld, rawPlates, rawNames, rawDatabase, rawStats) {
            if (error) throw error

            // Associate a name with each of the countries
            countries = topojson.feature(rawWorld, rawWorld.objects.countries)
            countries.features = countries.features.filter(function (d) {
              return rawNames.some(function (n) {
                if (d.id == n.id) {
                  d.name = n.name 
                  return true
                } 
              })
            })

            // Get features of the plates dataset
            plates = topojson.feature(rawPlates, rawPlates.objects.collection)
            
            // Preprocess database and stats
            database = rawDatabase
            stats = rawStats

            // Throw out stats with no corresponding country (less than 5% of dataset)
            stats = stats.filter(function (d) {
              return countries.features.some(function (n) {
                var dname = d.country.toLowerCase().split(":")[0]
                var nname = n.name.toLowerCase().split(" and ")
                if (nname.some(k => dname.includes(k))) {
                  d.country = n.name
                  d.id = n.id
                  return true
                }
              })
            })

            // Remove earthquake from database if its associated with a stat
            database = database.filter(function (d) {
              var found = stats.some(function (n) {
                if (n.date == d.date && n.time == d.time) {
                  return true
                }
              })
              return found ? false : true
            })

            // Projection and path generators for map
            projection = d3.geoKavrayskiy7()
              .scale(153)
              .fitExtent([[0,0], 
                  [mapSvg.attr("width"), mapSvg.attr("height")]
                ], 
                countries)
            pathGenerator = d3.geoPath().projection(projection)

            // Pre-compute useful information about the datasets
            depthExtent = d3.extent(database, d => d.depth)

            // Load the main view
            loadView()
          }

          // Load our view
          function loadView(year) {
            loadMap()            
            loadSlider()
            updateYear(currentYear) //default year
          }

          // Load our map with some config constraints
          function loadMap() {
            // Draw the tectonic plates
            var pathsPlate = platesGroup.selectAll(".plate").data(plates.features)
            pathsPlate.exit().remove()
            pathsPlate.enter()
              .append("path")
              .attr("class", "plate")
              .merge(pathsPlate) 
              .attr("d", pathGenerator)
              .style("fill", "white")
              .style("stroke", "green")
              .style("opacity", 0.2)

            // Draw the countries
            var pathsCountry = countriesGroup.selectAll(".country").data(countries.features)
            pathsCountry.exit().remove()
            pathsCountry.enter()
              .append("path")
              .attr("class", "country")
              .merge(pathsCountry) 
              .attr("d", pathGenerator)
              .style("fill", "white")
              .style("stroke", "black")

          }

          // Update the earthquake locations displayed to show
          function updateYear(year) {

            // Filter data by year
            databaseYear = database.filter(function (d) {
              return d.year == year
            })

            // Filter stats by year
            statsYear = stats.filter(function (d) {
              return d.year == year
            })

            // Filter countries by year
            countriesYear = countries.features.filter(function (d) {
              return statsYear.some(function (n) {
                if (n.id == d.id) return true
              })
            })

            // Depth scale (just in case)
            var r = d3.scaleLinear().domain(depthExtent).range([3, 10])

            // Draw the countries
            var pathsDamaged = damagedGroup.selectAll(".damaged").data(countriesYear)
            pathsDamaged.exit().remove()
            pathsDamaged.enter()
              .append("path")
              .attr("class", "damaged")
              .merge(pathsDamaged) 
              .attr("d", pathGenerator)
              .style("fill", "orange")

            // Draw the circles for every earthquake
            var circlesEarthquake = earthquakesGroup.selectAll(".earthquake").data(databaseYear)
            circlesEarthquake.exit().remove()
            circlesEarthquake.enter()
              .append("circle")
              .attr("class", "earthquake")
              .merge(circlesEarthquake)
              .attr("cx", function (d) { return projection([d.lng, d.lat])[0] })
              .attr("cy", function (d) { return projection([d.lng, d.lat])[1] })
              .attr("r", 4)
              .style("fill", "blue")
              .style("opacity", 1)
            
            // Draw the circles for every earthquake in the stats
            var circlesDisaster = disastersGroup.selectAll(".disaster").data(statsYear)
            circlesDisaster.exit().remove()
            circlesDisaster.enter()
              .append("circle")
              .attr("class", "disaster")
              .merge(circlesDisaster)
              .attr("cx", function (d) { return projection([d.lng, d.lat])[0] })
              .attr("cy", function (d) { return projection([d.lng, d.lat])[1] })
              .attr("r", 4)
              .style("fill", "blue")
              .style("opacity", 1)
            
            statText4.text(databaseYear.length + " Earthquakes")

            updateDonut()

            // Update the header
            d3.select("h1").text("Earthquakes versus Us: " + year)
          }

          // Draw the pie chart displaying countries affected
          function updateDonut() {
            // Determine the radious for the pie chart
            var radius = Math.min(pieSvg.attr("width"), pieSvg.attr("height")) / 2
            
            // Accumulate the countries damaged in a JSON
            var countriesDamaged = {}
            for (var i = 0; i < statsYear.length; i++) {
              var stat = statsYear[i]
              if (countriesDamaged[stat.country] == undefined) {
                countriesDamaged[stat.country] = stat.deaths
              } else {
                countriesDamaged[stat.country] = countriesDamaged[stat.country] + stat.deaths
              }
            }

            var totalDeaths = d3.sum(statsYear, d => d.deaths)
            var numberDisasters = statsYear.length

            // Convert this JSON into an array
            var countryDeaths = []
            for (country in countriesDamaged) {
              countryDeaths.push({
                country: country,
                deaths: countriesDamaged[country]
              })
            } 
            countryDeaths.sort(function (a, b) {
              return a.country.localeCompare(b.country)
            })

            // A pie that uses the log() of deaths as its values
            var pie = d3.pie()
            .value(d => Math.log(d.deaths)/Math.log(2))

            // An arc configure for maximum donutness
            var arc = d3.arc()
            .innerRadius(radius * 3 / 8)
            .outerRadius(radius * 7 / 8)

            // Draw the arc for country
            var arcsStat = pieSvg.selectAll(".arc").data(pie(countryDeaths))
            arcsStat.exit().remove()
            arcsStat.enter()
              .append("path")
              .attr("class", "arc")
              .merge(arcsStat)
              .attr("d", arc)
              .attr("transform", "translate(" + pieSvg.attr("width") / 2 + "," + (pieSvg.attr("height") / 2 + 25) + ")")
              .style("fill", "orange")
              .style("stroke", "white")
              .style("opacity", 1)
              .on("mouseover", mouseoverCountry)
              .on("mouseout", mouseoutCountry)

            statText2.text(totalDeaths + " Deaths")
            statText3.text(numberDisasters + " Disasters")
            
          }

          // Mouseover callback for country in pie char
          function mouseoverCountry(d) {

            currentCountry = d.data.country

            var width = mapSvg.attr("width")
            var height = mapSvg.attr("height")

            var countryBounds = pathGenerator.bounds(countriesYear
                .filter(d => d.name == currentCountry)[0])
            var earthquakeLocations = statsYear.filter(d => d.country == currentCountry)
              .map(d => projection([d.lng, d.lat]))

            var bounds = countryBounds
            for (var i; i < earthquakeLocations.length; i++) {
              var loc = earthquakeLocations[i]
              var lng = loc[0]
              var lat = loc[1]
              if (lng < bounds[0][0]) {
                bounds[0][0] = lng
              }
              if (lng > bounds[1][0]) {
                bounds[1][0] = lng
              }
              if (lat < bounds[0][1]) {
                bounds[0][1] = lat
              }
              if (lat > bounds[1][1]) {
                bounds[1][1] = lat
              }
            }

            var dx = bounds[1][0] - bounds[0][0]
            var dy = bounds[1][1] - bounds[0][1]
            var x = (bounds[0][0] + bounds[1][0]) / 2
            var y = (bounds[0][1] + bounds[1][1]) / 2
            var scale = .9 / Math.max(dx / width, dy / height)
            var translate = [width / 2 - scale * x, height / 2 - scale * y]

            mapGroup
              .transition()
              .duration(ZOOM_TIME)
              .attr("transform", "translate(" + translate + ")scale(" + scale + ")")
              .tween("others", function () {
                
                var damagedUnselected = damagedGroup.selectAll(".damaged")
                  .filter(d => d.name != currentCountry)
                var damagedSelected = damagedGroup.selectAll(".damaged")
                  .filter(d => d.name == currentCountry)
                var disasters = disastersGroup.selectAll(".disaster")
                var disastersUnselected = disastersGroup.selectAll(".disaster")
                  .filter(d => d.country != currentCountry)
                var disastersSelected = disastersGroup.selectAll(".disaster")
                  .filter(d => d.country == currentCountry)
                
                var i1 = d3.interpolateString(
                  platesGroup.style("stroke-width"), 
                  (4 / scale) + "px")
                var i2 = d3.interpolateString(
                  countriesGroup.style("stroke-width"), 
                  (1 / scale) + "px")
                var i3 = d3.interpolateString(
                  damagedUnselected.style("opacity"),
                  "0")
                var i4 = d3.interpolateString(
                  damagedSelected.style("opacity"),
                  "1")
                var i5 = d3.interpolateString(
                  earthquakesGroup.style("opacity"),
                  "0")
                var i6 = d3.interpolateString(
                  disasters.attr("r"),
                  16 / scale + "px")
                var i7 = d3.interpolateString(
                  disastersUnselected.style("opacity"),
                  "0")
                var i8 = d3.interpolateString(
                  disastersSelected.style("opacity"),
                  "1")

                return function(t) {
                  platesGroup.style("stroke-width", i1(t))
                  countriesGroup.style("stroke-width", i2(t))
                  damagedUnselected.style("opacity", i3(t))
                  damagedSelected.style("opacity", i4(t))
                  earthquakesGroup.style("opacity", i5(t))
                  disasters.attr("r", i6(t))
                  disastersUnselected.style("opacity", i7(t))
                  disastersSelected.style("opacity", i8(t))
                }
              })

          }

          function mouseoutCountry(d) {

            mapGroup.transition()
              .duration(ZOOM_TIME)
              .attr("stroke-width", 1).attr("transform", "")
              .tween("others", function () {

                var damagedUnselected = damagedGroup.selectAll(".damaged")
                  .filter(d => d.name != currentCountry)
                var damagedSelected = damagedGroup.selectAll(".damaged")
                  .filter(d => d.name == currentCountry)
                var disasters = disastersGroup.selectAll(".disaster")
                var disastersUnselected = disastersGroup.selectAll(".disaster")
                  .filter(d => d.country != currentCountry)
                var disastersSelected = disastersGroup.selectAll(".disaster")
                  .filter(d => d.country == currentCountry)
                
                var i1 = d3.interpolateString(
                  platesGroup.style("stroke-width"), 
                  1 + "px")
                var i2 = d3.interpolateString(
                  countriesGroup.style("stroke-width"), 
                  1 + "px")
                var i3 = d3.interpolateString(
                  damagedUnselected.style("opacity"),
                  "1")
                var i4 = d3.interpolateString(
                  damagedSelected.style("opacity"),
                  "1")
                var i5 = d3.interpolateString(
                  earthquakesGroup.style("opacity"),
                  "1")
                var i6 = d3.interpolateString(
                  disasters.attr("r"),
                  4 + "px")
                var i7 = d3.interpolateString(
                  disastersUnselected.style("opacity"),
                  "1")
                var i8 = d3.interpolateString(
                  disastersSelected.style("opacity"),
                  "1")

                return function(t) {
                  platesGroup.style("stroke-width", i1(t))
                  countriesGroup.style("stroke-width", i2(t))
                  damagedUnselected.style("opacity", i3(t))
                  damagedSelected.style("opacity", i4(t))
                  earthquakesGroup.style("opacity", i5(t))
                  disasters.attr("r", i6(t))
                  disastersUnselected.style("opacity", i7(t))
                  disastersSelected.style("opacity", i8(t))
                }
              })
              .on("end", function () {
                currentCountry = null
              })


          }

          // Load a slider
          function loadSlider() {
            var drag = d3.drag()
            .on("drag", sliderYear)

            // Default the slider at one end
            timeSvg.datum({
              x: timeSlider.left,
              y: timeSlider.top
            })

            // Draw a line for the slider axis
            timeSlider.axis = timeSvg.append("line")
              .attr("x1", timeSlider.left)
              .attr("x2", timeSlider.right)
              .attr("y1", timeSlider.top)
              .attr("y2", timeSlider.top)
              .style("stroke", "#ddd")
              .style("stroke-width", 5)

            // Draw a circle for the slider handler
            timeSlider.handler = timeSvg.append("circle")
              .attr("r", 10)
              .attr("cy", function(d) { return d.y })
              .attr("cx", function(d) { return d.x })
              .style("fill", "#fff")
              .style("stroke", "#000")
              .call(drag)

            // Attach an axis showing the years
            timeSvg.append("g")
              .attr("transform", "translate(0," + timeSlider.bottom + ")")
              .call(d3.axisBottom(timeSlider.scale)
                .tickFormat(d3.format("d")))

          }

          // Slider callback for changing time
          function sliderYear(d) {
            var xmin = timeSlider.left
            var xmax = timeSlider.right

            // Bound the event's x coordinate
            var x = d3.event.x            
            x = x < xmin ? xmin : x > xmax ? xmax : x

            // Compute the year and recompute the the snapped location
            x = (x - timeSlider.left) / (timeSlider.right - timeSlider.left)
            x *= (YEAR_MAX - YEAR_MIN)
            x = YEAR_MIN + Math.floor(x + 0.5) 

            // Alter the slider and current year if there's a change
            if (currentYear != x) {
              updateYear(x)
              currentYear = x
              x = timeSlider.scale(x)
              d.x = x
              timeSlider.handler.attr("cx", x)
            }
            
          }

        </script>
      </div>

  </body>
</html>