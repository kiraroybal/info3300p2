<!DOCTYPE html>
<html>
  <head>
    <title>Earthquakes</title>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="http://d3js.org/topojson.v2.min.js"></script>
    <script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
    <style>

      h1 {
        text-align: center;
        font-family: Helvetica;
        font-size: 72;
      }

      div#page {
        margin: 0 auto;
      }

    </style>
  </head>
  <body>

    <div id="page">
        <h1></h1>
        <svg id="map" width="1000" height="500"></svg>
        <svg id="pie" width="300" height="500"></svg>   
        <br>
        <svg id="time" width="1000" height="70"></svg>   
    </div>
    <p id="slider"></p>

        <script type="text/javascript">
          // Constants
          var YEAR_MIN = 1965
          var YEAR_MAX = 2016
          
          // The data we are visualizing
          var countries;
          var plates;
          var database;
          var stats;

          // "Indicator" variables for out data
          var currentYear = YEAR_MIN
          var depthExtent; 

          // SVGs
          var mapSvg = d3.select("#map");
          var timeSvg = d3.select("#time");
          var pieSvg = d3.select("#pie");

          // Projection and path generators for map
          var projection = d3.geoKavrayskiy7().scale(153);
          var pathGenerator = d3.geoPath().projection(projection);

          // A JSON representing our slider, with some sizing constraints
          var timeSlider = {
            top: 20,
            bottom: 35,
            left: 120,
            right: timeSvg.attr("width") - 120,
            scale: d3.scaleLinear()
              .domain([YEAR_MIN, YEAR_MAX])
              .range([120, timeSvg.attr("width") - 120]),
            thickness: 5,
            radius: 10,
            axis: null,
            handler: null
          };

          // Turn each value in a row of the database into a something workable
          function parseDatabase(row) {
            time = row.Time.split(":")

            d = {
              lat: +row.Latitude,
              lng: +row.Longitude,
              depth: +row.Depth,
              date: row.Date,
              time: time[0] + ":" + time[1],
              year: +row.Date.split("/")[2]
            };

            return d;
          }

          // Turn each value in a row of the stats into a something workable
          function parseStats(row) {

            d = {
              date: row.MONTH + "/" + row.DAY + "/" + row.YEAR,
              time: row.HOUR + ":" + row.MINUTE,
              year: +row.YEAR,
              country: row.COUNTRY,
              deaths: row.DEATHS
            };

            return d;
          }

          // Load each of the pieces we need
          d3.queue()
          .defer(d3.json, "world-50m.json")
          .defer(d3.json, "PB2002_plates.json")
          .defer(d3.tsv, "world-country-names.tsv")
          .defer(d3.csv, "earthquake-database.csv", parseDatabase)
          .defer(d3.json, "earthquake-stats.json")
          .await(ready);

          // Once data is ready, perform some preprocessing
          function ready(error, rawWorld, rawPlates, rawNames, rawDatabase, rawStats) {
            if (error) throw error

            // Associate a name with each of the countries
            countries = topojson.feature(rawWorld, rawWorld.objects.countries);
            countries.features = countries.features.filter(function (d) {
              return rawNames.some(function (n) {
                if (d.id == n.id) return d.name = n.name;
              });
            }).sort(function (a, b) {
              return a.name.localeCompare(b.name);
            });

            // Hold onto other datasets
            plates = topojson.feature(rawPlates, rawPlates.objects.collection);
            
            // Preprocess database
            database = rawDatabase;
            stats = rawStats;

            stats = stats.filter(function (d) {
              return countries.features.some(function (n) {
                var dname = d.country.toLowerCase();
                var nname = n.name.toLowerCase().split(" and ");
                if (nname.some(k => dname.includes(k))) {
                  d.country = n.name;
                  return d.id = n.id
                }
              })
            });

            database = database.filter(function (d) {
              if (stats.some(function (n) {
                if (n.date == d.date && n.time == d.time) {
                  return true
                }
              })) {
               return false
              } else {
                return true
              }
            });

            // Pre-compute useful information about the datasets
            depthExtent = d3.extent(database, d => d.depth)

            loadView();
          }

          // Load our view
          function loadView(year) {
            loadMap()            
            loadSlider()
            updateYear(currentYear); //default year
          };

          // Load our map with some config constraints
          function loadMap() {
            var width = mapSvg.attr("width");
            var height = mapSvg.attr("height");

            // Draw the map
            projection.fitExtent([[0,0], [width, height]], countries);
            pathGenerator = d3.geoPath().projection(projection);

            // Draw the tectonic plates
            var tectonicPaths = mapSvg.selectAll("path.tectonic").data(plates.features);
            tectonicPaths.enter()
            .append("path")
            .attr("class", "tectonic")
            .merge(tectonicPaths) 
            .style("fill", "white")
            .style("stroke", "green")
            .style("stroke-width", 1)
            .style("opacity", 0.2)
            .attr("d", function (country) {
              return pathGenerator(country);
            });

            // Draw the countries
            var countryPaths = mapSvg.selectAll("path.country").data(countries.features);
            countryPaths.enter()
            .append("path")
            .attr("class", "country")
            .merge(countryPaths) 
            .style("fill", "white")
            .style("stroke", "black")
            .attr("d", function (country) {
              return pathGenerator(country);
            });
          }

          // Load a slider
          function loadSlider() {
            var drag = d3.drag()
            .on("drag", sliderInput);

            // Default the slider at one end
            timeSvg.datum({
              x: timeSlider.left,
              y: timeSlider.top
            });

            // Draw a line for the slider axis
            timeSlider.axis = timeSvg.append("line")
            .attr("x1", timeSlider.left)
            .attr("x2", timeSlider.right)
            .attr("y1", timeSlider.top)
            .attr("y2", timeSlider.top)
            .style("stroke", "#ddd")
            .style("stroke-width", 5)

            // Draw a circle for the slider handler
            timeSlider.handler = timeSvg.append("circle")
            .attr("r", 10)
            .attr("cy", function(d) { return d.y; })
            .attr("cx", function(d) { return d.x; })
            .style("fill", "#fff")
            .style("stroke", "#000")
            .call(drag);

            // Attach an axis showing the years
            timeSvg.append("g")
            .attr("transform", "translate(0," + timeSlider.bottom + ")")
            .call(d3.axisBottom(timeSlider.scale)
              .tickFormat(d3.format("d")));

          }

          // Update the earthquake locations displayed to show
          function updateYear(year) {

            // Filter out the data for each year
            var year_data = database.filter(function (d) {
              return d.year == year;
            });

            var year_stats = stats.filter(function (d) {
              return d.year == year;
            });

            var country_stats = countries.features.filter(function (d) {
              return year_stats.some(function (n) {
                if (n.id == d.id) return true;
              })
            })

            // Depth scale
            var r = d3.scaleLinear().domain(depthExtent).range([3, 10]);

            // Draw the countries
            var countryPaths = mapSvg.selectAll("path.stat").data(country_stats);
            countryPaths.exit().remove()
            countryPaths.enter()
            .append("path")
            .attr("class", "stat")
            .merge(countryPaths) 
            .style("fill", "orange")
            .attr("d", pathGenerator)
            .style("opacity", 0.0)
            //.transition().duration(250)
            .style("opacity", 1);

            // Draw the circles for every earthquake
            var circlesYear = mapSvg.selectAll("circle.year").data(year_data);
            circlesYear.exit().remove()
            circlesYear.enter()
            .append("circle")
            .attr("class", "year")
            .merge(circlesYear)
            .attr("cx", function (d) { return projection([d.lng, d.lat])[0]; })
            .attr("cy", function (d) { return projection([d.lng, d.lat])[1]; })
            .attr("r", 4)
            .style("fill", "blue")
            .style("opacity", 0.0)
            //.transition().duration(250)
            .style("opacity", 0.7);
            
            // Draw the circles for every earthquake in the stats
            var circlesStats = mapSvg.selectAll("circle.stat").data(year_stats);
            circlesStats.exit().remove()
            circlesStats.enter()
            .append("circle")
            .attr("class", "stat")
            .merge(circlesStats)
            .attr("cx", function (d) { return projection([d.lng, d.lat])[0]; })
            .attr("cy", function (d) { return projection([d.lng, d.lat])[1]; })
            .attr("r", 4)
            .style("fill", "blue")
            .style("opacity", 0.0)
            //.transition().duration(250)
            .style("opacity", 0.7);
            

            var radius = Math.min(pieSvg.attr("width"), pieSvg.attr("height")) / 2

            var pie = d3.pie()
            .value(d => d.deaths);

            var arc = d3.arc()
            .innerRadius(radius * 4 / 8)
            .outerRadius(radius * 6 / 8)

            var arcsStats = pieSvg.selectAll("path.arc").data(pie(year_stats));
            arcsStats.exit().remove()
            arcsStats.enter()
            .append("path")
            .attr("class", "arc")
            .merge(arcsStats)
            .style("fill", "orange")
            .style("stroke", "white")
            .attr("d", arc)
            .attr("transform", "translate(" + pieSvg.attr("width") / 2 + "," + pieSvg.attr("height") / 2 + ")")
            .style("opacity", 0.0)
            //.transition().duration(250)
            .style("opacity", 1);

            // Update the header
            d3.select("h1").text("Earthquakes versus Us: " + year)
          }

          // Slider handler
          function sliderInput(d) {
            var xmin = timeSlider.left
            var xmax = timeSlider.right

            // Bound the event's x coordinate
            var x = d3.event.x;            
            x = x < xmin ? xmin : x > xmax ? xmax : x;

            // Compute the year and recompute the the snapped location
            x = (x - timeSlider.left) / (timeSlider.right - timeSlider.left);
            x *= (YEAR_MAX - YEAR_MIN);
            x = YEAR_MIN + Math.floor(x + 0.5) ;
            if (currentYear != x) {
              updateYear(x);
              currentYear = x;
              x = timeSlider.scale(x);

              d.x = x;
              
              timeSlider.handler.attr("cx", x);
            }
            
          }

        </script>
      </div>

  </body>
</html>